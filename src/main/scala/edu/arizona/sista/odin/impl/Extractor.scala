package edu.arizona.sista.odin.impl

import edu.arizona.sista.struct.Interval
import edu.arizona.sista.processors.Document
import edu.arizona.sista.odin._

trait Extractor {
  def name: String
  def label: String
  def priority: Priority
  def keep: Boolean  // should we keep mentions generated by this extractor?
  def action: ReflectedAction

  def findAllIn(sent: Int, doc: Document, state: State): Seq[Mention]

  def findAllIn(doc: Document, state: State): Seq[Mention] = for {
    i <- 0 until doc.sentences.size
    m <- findAllIn(i, doc, state)
  } yield m

  def startsAt: Int = priority match {
    case ExactPriority(i) => i
    case IntervalPriority(start, end) => start
    case FromPriority(from) => from
  }
}

class TokenExtractor(val name: String,
                     val label: String,
                     val priority: Priority,
                     val keep: Boolean,
                     val action: ReflectedAction,
                     val pattern: TokenPattern) extends Extractor {

  def findAllIn(sent: Int, doc: Document, state: State): Seq[Mention] = for {
    r <- pattern.findAllIn(sent, doc, state)
    m = mkMention(r, sent, doc)
    mention <- action(m, state)
  } yield mention

  def mkMention(r: TokenPattern.Result, sent: Int, doc: Document): Mention = {
    if (r.groups contains "trigger") {
      val trigger = new TextBoundMention(label, r.groups("trigger"), sent, doc, keep, name)
      val groups = r.groups - "trigger" mapValues (i => Seq(new TextBoundMention(label, i, sent, doc, keep, name)))
      val mentions = r.mentions mapValues (Seq(_))
      val args = groups ++ mentions
      new EventMention(label, trigger, args, sent, doc, keep, name)
    } else if (r.groups.nonEmpty || r.mentions.nonEmpty) {
      val groups = r.groups mapValues (i => Seq(new TextBoundMention(label, i, sent, doc, keep, name)))
      val mentions = r.mentions mapValues (Seq(_))
      val args = groups ++ mentions
      new RelationMention(label, args, sent, doc, keep, name)
    } else {
      new TextBoundMention(label, r.interval, sent, doc, keep, name)
    }
  }
}

class DependencyExtractor(val name: String,
                          val label: String,
                          val priority: Priority,
                          val keep: Boolean,
                          val action: ReflectedAction,
                          val pattern: DependencyPattern) extends Extractor {

  def findAllIn(sent: Int, doc: Document, state: State): Seq[Mention] = for {
    m <- pattern.getMentions(sent, doc, state, label, keep, name)
    mention <- action(m, state)
  } yield mention
}
